---
title: "download_data"
author: "steppe"
date: "4/8/2022"
output: html_document
---


You will need to download a vector file which contains the BLM office boundaries.
```{r Load packages, message = F, warning = F}
library(tidyverse)
library(here)
library(FedData)
library(sf)
library(raster) # needed for gdistance
library(terra)
library(whitebox)
library(gdistance)
#set_here('..')
```

```{r Read in and Subset BLM field offices}
FO <- st_read(paste0(here(), "/data/raw/blm_co_admu_fo_shp/BLM_CO_ADMU_FO_20201001.shp"),
              quiet = T)

FO <- FO %>% 
  filter(ADMU_NAME == 'UNCOMPAHGRE FIELD OFFICE') %>% 
  st_transform(4269) %>% 
  as('Spatial')
```


```{r Read in AIM points}

```


### Slope Calculations 

This code serves to download 10m resolution DEM. 
```{r download DEM, eval = F}
#dir.create(paste0(here(), '/data/raw/DEM'))
links <- read.csv(
  paste0(here(), '/data/raw/', 'DEM_file_paths.csv'), header = F)[,c(1,15)]
names(links) <- c('Tile', 'URL')

links <- links %>% 
  mutate(Tile = str_extract_all(Tile, 'n\\d{2}w\\d{3}')) %>% 
  mutate(Tile = paste0(Tile, '_10m_DEM.tif'))

destfile <- paste0(here(), '/data/raw/DEM/', links$Tile)
download.file(links$URL[1], destfile[1])

for (i in 1:length(destfile)){
  
  download.file(links$URL[i], destfile[i])
  Sys.sleep(5)
  message("File downloaded and saved to location: " destfile[i])
}
rm(links, destfile, i)
```

Here we crop the extent of the rasters, and mosaic them together to form a a raster for easier usage.
```{r Load and Mosaic rasters into Spatstat object, eval = F}
raster_files <- paste0(here(), '/data/raw/DEM/', 
                       list.files(paste0(here(), '/data/raw/DEM/')))

raster_files = lapply(raster_files, rast)
rsrc <- sprc(raster_files)
m <- mosaic(rsrc)

FO <- FO %>% 
  st_as_sf() %>% 
  st_transform(32613) %>% 
  st_buffer(80) %>%  # we are just going to buffer a little bit to make sure our edges are nice
  st_transform(crs(m)) %>% 
  vect()

dem <- crop(m, FO)
dem <- terra::mask(dem, FO)

writeRaster(dem, paste0(here(), '/data/raw/UFO_dem_10m.tif'))
rm(raster_files, rsrc, m)
```

We will finally create a raster with modeled slope values. 
```{r Create Slope Raster, eval = F}
dem <- rast(paste0(here(), '/data/raw/UFO_dem_10m.tif'))

terrain(dem, v = 'slope', neighbors = 8, unit = 'degrees', 
               filename = paste0(here(), '/data/processed/UFO_slope_deg.tif')
               )
terrain(dem, v = 'aspect', neighbors = 8, unit = 'degrees', 
               filename = paste0(here(), '/data/processed/UFO_aspect.tif')
               )
terrain(dem, v = 'TRI', neighbors = 8, unit = 'degrees', 
               filename = paste0(here(), '/data/processed/UFO_topo_roughness.tif')
               )

```

Points with greater than 26.57 degrees (slopes of 50*) are office rejections.
```{r Read in Slope degree raster, eval = F}
degrees<- rast(paste0(here(), '/data/processed/UFO_slope.tif'))
plot(degrees)
#aspect<- rast(paste0(here(), '/data/processed/UFO_aspect.tif'))
#plot(aspect)
#tri <- rast(paste0(here(), '/data/processed/UFO_topo_roughness.tif'))
#plot(tri)

rm(aspect, tri)
```


```{r Create Geomorphons and Hydrologic Basins of Field Office, eval = F}
data_proc <- paste0(here(),"/data/processed/")

Sys.time()
whitebox::wbt_feature_preserving_smoothing(paste0(here(),'/data/raw/UFO_dem_10m.tif'), 
                           paste0(data_proc, "UFO_dem_10_smooth.tif"), filter=9)

wbt_breach_depressions(paste0(data_proc, "UFO_dem_10_smooth.tif"), 
                   paste0(data_proc, "UFO_dem_10_sm_breached.tif"))

wbt_geomorphons(paste0(data_proc, "UFO_dem_10_sm_breached.tif"), 
                output = paste0(data_proc, "UFO_geomorphons_10m.tif"), 
                search = 50, forms = T)
Sys.time()


geomor <- raster::raster(paste0(data_proc, "UFO_geomorphons_10m.tif"))
plot(geomor)

rm(data_proc)
```


As a future endeavor we can use AIM data to test our slope value raster. Note this step is only possible if you have had previous AIM work carried out in the area. 

```{r Logistic Regression Determining Accuracy of classification, eval = F}

```


### Pull in and Process Road Data

```{r}
john_tigger <- function(x) {
  name <- x$NAME
  county_roads <- tigris::roads(state = x$STATEFP,
                                county = x$COUNTYFP, year = 2020)
  county_roads <- mutate(county_roads, NAME = name)
  
  return(county_roads)
}
```

```{r Pull in Road Data, warning = F, eval = F}
counties_filt <- tigris::counties(state = c('CO', 'UT'))
counties <- st_join(counties_filt, st_as_sf(FO), join = st_intersects, left = F)

# WE WILL NEED TO IMPORT JOHN_TIGGER FUNCTION FROM 'REVISIONARY TAXONOMY' - HOW YOU WANT DO THIS DORK? - IT COULD
# REQUIRE YOU ACTUALLY PUSHING A PACKAGE PUBLIC...

lst_result <- apply(counties, 1, john_tigger)
cnty_rds <- bind_rows(lst_result) %>% 
  st_as_sf()

FO_ch_15mi <- FO %>% 
  st_as_sf() %>% 
  st_transform(32613) %>% 
  st_buffer(16000.0934) %>% 
  st_transform(st_crs(cnty_rds)) %>% 
  select(2)

cnty_rds <- st_intersection(cnty_rds, FO_ch_15mi) # reduce extent.
inter <- st_intersects(cnty_rds,cnty_rds, sparse = TRUE)
cnty_rds <- cnty_rds[lengths(inter)>1,]

cnty_rds <- cnty_rds %>% 
  st_transform(32613) %>% 
  st_simplify(., preserveTopology = FALSE, dTolerance = 20)

ggplot(counties) +
  geom_sf() +
  geom_sf(data = st_as_sf(FO), fill = 'blue', alpha = 0.5) +
  geom_sf(data = cnty_rds, alpha = 0.7) +
  theme_bw()

st_write(cnty_rds, paste0(here(), '/data/processed/UFO_roads.shp'), quiet =T)
rm(lst_result, john_tigger, FO_ch_15mi, counties_filt, inter)
```


```{r Reduce Road Data to remove disconnected roads}

cnty_rds <- st_read(paste0(here(), '/data/processed/UFO_roads.shp'), quiet =T)


#touching <- st_touches(cnty_rds)
#v <- touching[1:length(touching)] != "integer(0)"
#touching <- cnty_rds[v,]
```


### Load 

### Locate most proximal road access to Points

```{r Find most proximal points to road}
pts <- st_read(paste0(here(), '/data/raw/AIM_Points_2022.shp')) %>% 
  st_transform(st_crs(cnty_rds))

res <- st_nearest_feature(pts, cnty_rds)

closest_rds <- cnty_rds[res,]
distances <- st_distance(pts, cnty_rds[res,], by_element = TRUE)
np_linestrings <- st_nearest_points(pts, closest_rds, pairwise = TRUE)

cnty_rds1 <- st_transform(cnty_rds, 26912) %>% 
  group_by(FULLNAME) %>% 
  summarize(geometry = st_union(geometry)) %>% 
  st_cast('MULTILINESTRING') %>% 
  st_transform(st_crs(closest_rds))

res_fuck <- st_touches(closest_rds, cnty_rds1) %>% unlist()
cnty_rds1 <- cnty_rds1[res_fuck,]

ggplot(pts) +
  geom_sf() +
  geom_sf(data = closest_rds, color = 'blue') +
  geom_sf(data = np_linestrings, color = 'red')

```

### Determine whether these roads follow public access or cross private without right of way


```{r gdistance example}
r <- raster(system.file("external/maungawhau.grd", package="gdistance"))

altDiff <- function(x){x[2] - x[1]}
hd <- transition(r, altDiff, 16, symm=FALSE)
slope <- geoCorrection(hd)
adj <- adjacent(r, cells=1:ncell(r), pairs=TRUE, directions=16)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed) 

A <- c(2667670, 6479000)
B <- c(2667800, 6479400)
AtoB <- shortestPath(Conductance, A, B, output="SpatialLines")
BtoA <- shortestPath(Conductance, B, A, output="SpatialLines")

plot(r, xlab="x coordinate (m)", ylab="y coordinate (m)",
     legend.lab="Altitude (masl)")
lines(AtoB, col="red", lwd=2)
lines(BtoA, col="blue")
text(A[1] - 10, A[2] - 10, "A")
text(B[1] + 10, B[2] + 10, "B")

rm(altDiff, hd, slope, adk, speed, Conductance, A, B, AtoB, BtoA)
```

```{r worked examples}


altDiff <- function(x){x[2] - x[1]}
hd <- transition(dem, altDiff, 16, symm=FALSE)
slope <- geoCorrection(hd)
adj <- adjacent(dem, cells=1:ncell(r), pairs=TRUE, directions=16)
speed <- slope
speed[adj] <- 6 * exp(-3.5 * abs(slope[adj] + 0.05))
Conductance <- geoCorrection(speed) 

parking <- park2point %>% 
  filter(location == 'parking')
point <- park2point %>% 
  filter(location == 'point') 

to_plot <- shortestPath(Conductance, parking, point, output="SpatialLines")
from_plot <- shortestPath(Conductance, point, parking, output="SpatialLines")

```

```{r}
p1 <- paste0(here(), '/data/raw/', 
       list.files(paste0(here(), '/data/raw/'), pattern = 'PADUS'), "/")
PAD <- st_read(paste0(p1, list.files(p1, pattern = 'Fee.*\\.shp$')), quiet = T)
PAD_valid <- PAD %>% st_is_valid()
PAD[which(PAD_valid %in% F),] <- st_make_valid(PAD[which(PAD_valid %in% F),])

dem <- rast(paste0(here(), '/data/processed/', "UFO_dem_10_smooth.tif"))
# dem <- terra::project(dem, "epsg:26912")
# writeRaster(dem, paste0(here(), '/data/processed/', "UFO_dem_10_smooth_UTM.tif"))

park2point <- nearestPt2points(np_linestrings, pts$plot_id)

perspective_routes <- function(target_pts, roads, dem, search_dist, public_lands, road_segments){
  
  # this function will identify 5 positions (including the shortest distance)
  # from a road to an AIM point. Each of these 5 points will have the least cost
  # distance 'as the wolf runs' from them to the AIM point calculated. The top
  # 3 possible routes will be returned.
  
  # target_pts: AIM points as sf objects
  # roads: a road layer, such as TIGER, as multi-linestring
  # dem: a digital elevation model, in meters ala UTM (we recommend terra for projecting)
  # search_dist: radii from which to search for a route from 'roads' to 'target_pts'
  # public_lands: a vector dataset of public land owernship, can you only travel on these
  # road_segments: distance by which to 'chop up' a road so that multiple segments can be 
  # used for starting points, in meters.
  
  # helper functions:
  closest <- function(target, access){
    
    access <- st_transform(access, st_crs(target))
    distances <- st_distance(target, access)
    closest <- access[head(order(distances), 5), ]
    closest <- tibble('plot_id' = target$plot_id[1], closest)

  }
  # project all data to the crs of the digital elevation model
  pts <- st_transform(target_pts, crs(dem))
  roads <- st_transform(roads, crs(dem))
  public_lands <- st_transform(public_lands, crs(dem)) %>% 
    dplyr::select(geometry)
  
  # REDUCE EXTENT OF ANALYSIS TO STUDY AREAS 
  search_window <- st_buffer(pts, search_dist) %>% 
    dplyr::select(geometry)
  
  road_subset <- st_intersection(search_window, roads)
  road_subset <- st_intersection(public_lands, road_subset)
  
  # SPLIT ROADS INTO PIECES AND SELECT THOSE OF 1/8 ~ 1/4 MI
  road_subset <- rmapshaper::ms_simplify(road_subset, keep = 0.05) %>% 
    summarize(geometry = st_union(geometry))
  road_subset <- st_segmentize(road_subset, dfMaxLength = 400) 
  road_subset <- nngeo::st_segments(road_subset, progress = F)
  
  road_subset_length <- st_length(road_subset)
  road_subset <- road_subset[as.numeric(road_subset_length) > 250,]
  
  # identify up to the 5 nearest road segments
  pts_split <- split(pts, ~ pts$plot_id)
  rds <- bind_rows(lapply(pts_split, closest, access = road_subset)) %>% st_as_sf()
  
  recip_point <- rds %>% 
    dplyr::select(plot_id) %>% 
    st_drop_geometry()
  pts1 <- pts %>% 
    dplyr::select(plot_id) %>% 
    right_join(., recip_point)

  # return the nearest points along the road segments
  np_linestrings <- st_nearest_points(pts1, rds, pairwise = TRUE)
  resin <- nearestPt2points(np_linestrings, pts1$plot_id) %>% 
    distinct()

  return(resin)
}


ouro <- perspective_routes(target_pts = pts, roads = cnty_rds, dem = dem, 
                   search_dist = 4828, public_lands = PAD, road_segments = 400)



### testy why so slow

search_window <- st_buffer(pts, 4828) %>% 
  dplyr::select(geometry)
PAD1 <- st_transform(PAD, st_crs(road_subset))

road_subset <- st_intersection(search_window, cnty_rds)
road_subset <- st_intersection(PAD1, road_subset)
road_subset <- rmapshaper::ms_simplify(road_subset, keep = 0.05) %>% 
    summarize(geometry = st_union(geometry))
road_subset <- st_segmentize(road_subset, dfMaxLength = 400) 
road_subset <- nngeo::st_segments(road_subset, progress = F)
  
str(road_subset)
  
  pts_split <- split(pts, ~ pts$plot_id)
  rds <- bind_rows(lapply(pts_split, closest, access = road_subset)) %>% 
    st_as_sf()
  
recip_point <- rds %>% 
  dplyr::select(plot_id) %>% 
  st_drop_geometry()
  
pts1 <- pts %>% 
  dplyr::select(plot_id) %>% 
  right_join(., recip_point)

np_linestrings <- st_nearest_points(pts1, rds, pairwise = TRUE)

resin <- nearestPt2points(np_linestrings, pts1$plot_id) %>% 
  distinct()

ggplot(resin) +
  geom_sf(aes(colour = location))


```


